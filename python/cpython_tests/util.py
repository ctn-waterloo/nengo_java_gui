import inspect
import tempfile

jython_template = """
# -- Automatically-generated Jython file to run nef code fragment for unit
#    tests

# -- no-op decorator in auto-gen jython file
import logging
logging.basicConfig(stream=sys.stderr)

def nengo_log(f):
    return f

%(fn_def)s

net = %(fn_name)s(**%(fn_kwargs)s)
log = net.log(filename="%(logfile)s")
net.run(time=%(t)s, dt=%(dt)s)

"""

nengo_cl = '../../nengo-70ea992/nengo-cl'

keep_tempfiles = True

def nengo_log(f):

    def deco(t, dt=0.001, mode=None, seed=123, **kwargs):
        print f
        fn_def = inspect.getsource(f)
        assert fn_def.startswith('@nengo_log')
        fn_name = f.__name__
        fn_kwargs = repr(kwargs) # XXX
        logfile = 'logfile'
        jython_src = jython_template % locals()

        print jython_src

        pyfile = tempfile.NamedTemporaryFile(
            prefix='nengo_log',
            suffix='.py',
            delete=not keep_tempfiles)
        logfile = tempfile.NamedTemporaryFile(
            prefix='nengo_log',
            suffix='.csv',
            delete=not keep_tempfiles)

        print jython_src
        pyfile.write(jython_src)

        cmd = ['bash', nengo_cl, pyfile.name]
        print cmd
        return
        subprocess.check_call()

        print 'pyfile', pyfile.name
        print 'logfile', logfile.name

        return None

    deco.__name__ = f.__name__
    return deco

#
# Unit tests for basic network logging
#

import numpy as np

@nengo_log
def connect_something(orig=True):
    import nef
    net = nef.Network('top')
    netA = nef.Network('A')
    netB = nef.Network('B')
    netA.make('X', 100, 1)
    netA.make('Y', 100, 1)
    netB.make('X', 100, 1)
    netB.make('Y', 100, 1)
    net.add(netA.network)
    net.add(netB.network)
    net.connect('A.X', 'B.Y')

    if orig:
        return net
    else:
        net.add_to_nengo()
        jython_src = net.network.dumpToScript()
        # -- autogenerated code names the toplevel thing 'net'
        exec jython_src
        return net


def test_sane_stats():
    stats0 = connect_something(orig=True, t=1.0, seed=123, mode='spiking')
    assert len(stats0['A.X']) == 1000
    assert np.all(np.var(stats0) > 0)


def test_reproducible_small():
    stats0 = connect_something(orig=True, t=1.0, seed=123, mode='spiking')
    stats1 = connect_something(orig=True, t=1.0, seed=123, mode='spiking')
    assert np.all(stats0 == stats1)


def test_reproducible_large():
    # -- simulate a large model with lots of chances for accidentally
    #    re-seeding things
    raise NotImplementedError()
    stats0 == 0
    stats1 == 0
    assert np.all(stats0 == stats1)


def test_seed_doesnt_matter_very_much():
    stats0 = connect_something(orig=True, t=1.0, seed=123, mode='spiking')
    stats1 = connect_something(orig=True, t=1.0, seed=124, mode='spiking')
    assert not np.all(stats0 == stats1)
    assert abs(np.var(stats0) - np.var(stats1))


def test_seed():
    stats0 = connect_something(orig=True, t=1.0, seed=123, mode='direct')
    stats1 = connect_something(orig=False, t=1.0, seed=123, mode='direct')
    assert stats0 == stats1


