import inspect
import stats.reader
import subprocess
import tempfile

jython_template = """
# -- Automatically-generated Jython file to run nef code fragment for unit
#    tests
import sys

# -- no-op decorator in auto-gen jython file
import logging
logging.basicConfig(stream=sys.stderr)

def nengo_log(f):
    return f

%(fn_def)s

net = %(fn_name)s(logfile="%(logfile)s", **%(fn_kwargs)s)
net.run(time=%(t)s, dt=%(dt)s)

"""

nengo_cl = '../../../nengo-current/nengo-cl'

keep_tempfiles = True

def nengo_log(f):

    def deco(t, dt=0.001, **kwargs):
        pyfile = tempfile.NamedTemporaryFile(
            prefix='nengo_log',
            suffix='.py',
            delete=not keep_tempfiles)
        logfile = tempfile.NamedTemporaryFile(
            prefix='nengo_log',
            suffix='.csv',
            delete=not keep_tempfiles)

        #print f
        fn_def = inspect.getsource(f)
        assert fn_def.startswith('@nengo_log')
        jython_src = jython_template % dict(
            t=t,
            dt=dt,
            fn_def=fn_def,
            fn_name=f.__name__,
            fn_kwargs=repr(kwargs), # XXX only works for simple stuff
            logfile=logfile.name,
            )

        #print jython_src
        pyfile.write(jython_src)
        #pyfile.flush()
        pyfile.close()

        # print os.environ
        # print ' '.join([nengo_cl, pyfile.name])
        proc = subprocess.Popen(
            [nengo_cl, pyfile.name],
            #['ls', '-l'],
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            )
        proc.wait()
        if proc.returncode:
            comm = proc.communicate()
            print 'Subprocess failed'
            print comm[0]
            print comm[1]
            raise Exception('Failed to evaluate %s %s'
                            % (nengo_cl, pyfile.name))

        print 'nengo_log pyfile', pyfile.name
        print 'nengo_log logfile', logfile.name
        rval = stats.reader.Reader(logfile.name, dir='/', search=False)
        return rval

    deco.__name__ = f.__name__
    return deco

#
# Unit tests for basic network logging
#

import numpy as np

@nengo_log
def connect_something(logfile, orig=True, mode=None, seed=None):
    import nef
    net = nef.Network('top')
    netA = nef.Network('A')
    netB = nef.Network('B')
    netA.make('X', 100, 1)
    netA.make('Y', 100, 1)
    netB.make('X', 100, 1)
    netB.make('Y', 100, 1)
    net.add(netA.network)
    net.add(netB.network)
    net.connect('A.X', 'B.Y')
    #
    log = nef.log.TimelockedLog(network=net, filename=logfile)
    log.add('A.X')
    log.add('A.Y')
    log.add('B.X')
    log.add('B.Y')

    if orig:
        return net
    else:
        net.add_to_nengo()
        jython_src = net.network.dumpToScript()
        # -- autogenerated code names the toplevel thing 'net'
        exec jython_src
        return net


def test_sane_stats():
    stats0 = connect_something(orig=True, t=1.0, seed=123, mode='spiking')
    assert np.allclose(stats0['time'], np.arange(0.0, 1.0, .001)[:, None])
    assert len(stats0['A.X']) == 1000
    assert len(stats0['A.Y']) == 1000
    assert len(stats0['B.X']) == 1000
    assert len(stats0['B.Y']) == 1000
    assert np.all(np.var(stats0['A.X']) > 0)


def test_reproducible_small():
    stats0 = connect_something(orig=True, t=1.0, seed=123, mode='spiking')
    stats1 = connect_something(orig=True, t=1.0, seed=123, mode='spiking')
    assert np.all(stats0 == stats1)


def test_reproducible_large():
    # -- simulate a large model with lots of chances for accidentally
    #    re-seeding things
    raise NotImplementedError()
    stats0 == 0
    stats1 == 0
    assert np.all(stats0 == stats1)


def test_log_tau():
    raise NotImplementedError()


def test_seed_doesnt_matter_very_much():
    stats0 = connect_something(orig=True, t=1.0, seed=123, mode='spiking')
    stats1 = connect_something(orig=True, t=1.0, seed=124, mode='spiking')
    assert not np.all(stats0 == stats1)
    assert abs(np.var(stats0) - np.var(stats1))


def test_seed():
    stats0 = connect_something(orig=True, t=1.0, seed=123, mode='direct')
    stats1 = connect_something(orig=False, t=1.0, seed=123, mode='direct')
    assert stats0 == stats1


